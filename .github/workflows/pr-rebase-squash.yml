# NOTE: The `issue_comment` trigger runs the workflow from the **default branch**,
# not the PR branch. This workflow YAML must be merged to the default branch
# before it will respond to comments. This is a GitHub Actions platform
# constraint, not a bug.
#
# Slash-commands (via PR comment):
#   /rebase        ‚Äî Rebase the PR branch onto the base branch
#   /squash        ‚Äî Squash all PR commits into one with a Copilot-generated message
#   /rebase squash ‚Äî Rebase first, then squash
#
# Manual testing (via Actions tab ‚Üí "Run workflow"):
#   Provide the PR number and select the command to run.
#
# See docs/plans/pr-comment-rebase-squash-action.md for full design details.

name: PR Rebase & Squash

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull request number to operate on'
        required: true
        type: number
      command:
        description: 'Command to execute'
        required: true
        type: choice
        options:
          - rebase
          - squash
          - rebase squash

concurrency:
  group: pr-rebase-squash-${{ github.event.issue.number || inputs.pr_number }}
  cancel-in-progress: false

jobs:
  rebase-squash:
    name: Rebase / Squash
    runs-on: ubuntu-latest
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (
        github.event.issue.pull_request &&
        (
          contains(github.event.comment.body, '/rebase') ||
          contains(github.event.comment.body, '/squash')
        )
      )
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      # ‚îÄ‚îÄ 0. Normalize inputs across triggers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Normalize inputs
        id: ctx
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ inputs.pr_number }}" >> "$GITHUB_OUTPUT"
            echo "actor=${{ github.actor }}" >> "$GITHUB_OUTPUT"
            ACTOR_ID=$(gh api "users/${{ github.actor }}" --jq '.id')
            echo "actor_id=$ACTOR_ID" >> "$GITHUB_OUTPUT"
            echo "has_comment=false" >> "$GITHUB_OUTPUT"
          else
            echo "pr_number=${{ github.event.issue.number }}" >> "$GITHUB_OUTPUT"
            echo "actor=${{ github.event.comment.user.login }}" >> "$GITHUB_OUTPUT"
            echo "actor_id=${{ github.event.comment.user.id }}" >> "$GITHUB_OUTPUT"
            echo "has_comment=true" >> "$GITHUB_OUTPUT"
          fi

      # ‚îÄ‚îÄ 1. Permission check ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Check collaborator permission
        id: permission
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PERM=$(gh api "repos/${{ github.repository }}/collaborators/${{ steps.ctx.outputs.actor }}/permission" \
            --jq '.permission')
          if [[ "$PERM" != "admin" && "$PERM" != "write" && "$PERM" != "maintain" ]]; then
            echo "User ${{ steps.ctx.outputs.actor }} lacks write access (has: $PERM)"
            exit 1
          fi

      # ‚îÄ‚îÄ 2. Acknowledge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: React to comment
        if: steps.ctx.outputs.has_comment == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api "repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions" \
            -f content='eyes' --silent

      # ‚îÄ‚îÄ 3. Checkout PR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Get PR metadata
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_JSON=$(gh api "repos/${{ github.repository }}/pulls/${{ steps.ctx.outputs.pr_number }}")
          echo "head_ref=$(echo "$PR_JSON" | jq -r '.head.ref')" >> "$GITHUB_OUTPUT"
          echo "head_sha=$(echo "$PR_JSON" | jq -r '.head.sha')" >> "$GITHUB_OUTPUT"
          echo "base_ref=$(echo "$PR_JSON" | jq -r '.base.ref')" >> "$GITHUB_OUTPUT"
          echo "state=$(echo "$PR_JSON" | jq -r '.state')" >> "$GITHUB_OUTPUT"

      - name: Abort if PR is not open
        if: steps.pr.outputs.state != 'open'
        run: |
          echo "PR #${{ steps.ctx.outputs.pr_number }} is ${{ steps.pr.outputs.state }}, not open."
          exit 1

      - uses: actions/checkout@v6
        with:
          ref: ${{ steps.pr.outputs.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git identity
        run: |
          git config user.name "${{ steps.ctx.outputs.actor }}"
          git config user.email "${{ steps.ctx.outputs.actor_id }}+${{ steps.ctx.outputs.actor }}@users.noreply.github.com"

      # ‚îÄ‚îÄ 4. Parse command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Parse slash command
        id: cmd
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            COMMAND="${{ inputs.command }}"
          else
            COMMAND="${{ github.event.comment.body }}"
          fi
          DO_REBASE=false
          DO_SQUASH=false
          if echo "$COMMAND" | grep -qiE '(^\s*/)?rebase\s+squash\s*$'; then
            DO_REBASE=true
            DO_SQUASH=true
          elif echo "$COMMAND" | grep -qiE '(^\s*/)?rebase\s*$'; then
            DO_REBASE=true
          elif echo "$COMMAND" | grep -qiE '(^\s*/)?squash\s*$'; then
            DO_SQUASH=true
          fi
          echo "do_rebase=$DO_REBASE" >> "$GITHUB_OUTPUT"
          echo "do_squash=$DO_SQUASH" >> "$GITHUB_OUTPUT"

      # ‚îÄ‚îÄ 5. Rebase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Rebase onto base branch
        id: rebase
        if: steps.cmd.outputs.do_rebase == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BASE="${{ steps.pr.outputs.base_ref }}"
          git fetch origin "$BASE"

          if git rebase "origin/$BASE"; then
            echo "status=clean" >> "$GITHUB_OUTPUT"
          else
            echo "status=conflict" >> "$GITHUB_OUTPUT"
          fi

      # ‚îÄ‚îÄ 5b. Resolve conflicts with Copilot CLI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Resolve conflicts with Copilot CLI
        id: resolve
        if: steps.rebase.outputs.status == 'conflict'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COPILOT_GITHUB_TOKEN: ${{ secrets.COPILOT_PAT }}
        run: |
          npm install -g @github/copilot 2>/dev/null || true

          MAX_ROUNDS=10
          ROUND=0
          RESOLVED_FILES=""

          while [ "$ROUND" -lt "$MAX_ROUNDS" ]; do
            ROUND=$((ROUND + 1))
            CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || true)

            if [ -z "$CONFLICTS" ]; then
              # No more conflict markers ‚Äî rebase has landed cleanly
              echo "status=clean" >> "$GITHUB_OUTPUT"
              {
                echo "### ü§ñ Copilot resolved rebase conflicts"
                echo ""
                echo "Files resolved automatically:"
                for F in $RESOLVED_FILES; do echo "- \`$F\`"; done
              } >> "$GITHUB_STEP_SUMMARY"
              exit 0
            fi

            echo "Conflict resolution round $ROUND for: $CONFLICTS"
            ALL_RESOLVED=true

            while IFS= read -r FILE; do
              [ -z "$FILE" ] && continue
              CONFLICT_CONTENT=$(cat "$FILE")
              RESOLVED=$(copilot -p \
                "Resolve ALL git conflict markers (<<<<<<<, =======, >>>>>>>) in the file \
                 below. Output ONLY the complete resolved file content ‚Äî no markdown fences, \
                 no explanations, no preamble. File: $FILE --- Content: $CONFLICT_CONTENT" \
                2>/dev/null) || true

              # Strip fenced code blocks if present
              if [ -n "$RESOLVED" ] && echo "$RESOLVED" | grep -q '^```'; then
                RESOLVED=$(echo "$RESOLVED" | awk '/^```/{if(f){exit}else{f=1;next}} f{print}')
              fi

              # Accept only if non-empty and conflict markers are gone
              if [ -n "$RESOLVED" ] && ! echo "$RESOLVED" | grep -qF '<<<<<<<'; then
                printf '%s\n' "$RESOLVED" > "$FILE"
                git add "$FILE"
                RESOLVED_FILES="$RESOLVED_FILES $FILE"
              else
                ALL_RESOLVED=false
                echo "Copilot could not resolve conflicts in: $FILE"
              fi
            done <<< "$CONFLICTS"

            if [ "$ALL_RESOLVED" = "false" ]; then
              echo "status=unresolved" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # All conflicts in this round resolved ‚Äî continue the rebase
            if GIT_EDITOR=true git rebase --continue; then
              echo "status=clean" >> "$GITHUB_OUTPUT"
              {
                echo "### ü§ñ Copilot resolved rebase conflicts"
                echo ""
                echo "Files resolved automatically:"
                for F in $RESOLVED_FILES; do echo "- \`$F\`"; done
              } >> "$GITHUB_STEP_SUMMARY"
              exit 0
            fi
            # git rebase --continue hit the next commit's conflicts ‚Äî loop again
          done

          echo "status=unresolved" >> "$GITHUB_OUTPUT"

      - name: Abort on rebase conflicts
        if: steps.rebase.outputs.status == 'conflict' && steps.resolve.outputs.status != 'clean'
        run: |
          git rebase --abort
          echo "Rebase failed: Copilot could not resolve all conflicts automatically. Please resolve manually." >> "$GITHUB_STEP_SUMMARY"
          exit 1

      - name: Push rebased branch
        if: steps.cmd.outputs.do_rebase == 'true'
        run: git push --force-with-lease

      # ‚îÄ‚îÄ 6. Squash ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Squash commits
        if: steps.cmd.outputs.do_squash == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COPILOT_GITHUB_TOKEN: ${{ secrets.COPILOT_PAT }}
        run: |
          BASE="${{ steps.pr.outputs.base_ref }}"
          git fetch origin "$BASE"
          MERGE_BASE=$(git merge-base HEAD "origin/$BASE")

          COMMIT_COUNT=$(git rev-list --count "$MERGE_BASE..HEAD")
          if [ "$COMMIT_COUNT" -le 1 ]; then
            echo "Only $COMMIT_COUNT commit(s) ‚Äî nothing to squash." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          # Collect context for Copilot
          PR_NUMBER="${{ steps.ctx.outputs.pr_number }}"
          LOG=$(git log --oneline "$MERGE_BASE..HEAD")
          STAT=$(git diff --stat "$MERGE_BASE..HEAD")

          # PR title is always the subject line (follows Conventional Commits)
          TITLE=$(gh api "repos/${{ github.repository }}/pulls/${PR_NUMBER}" --jq '.title') || true
          if [ -z "$TITLE" ]; then
            TITLE="chore: squash ${COMMIT_COUNT} commits"
          fi

          # Try Copilot CLI for a full commit body description.
          # NOTE: stderr goes to /dev/null ‚Äî never capture it into the message
          # variable, since error text would bypass the empty-string fallback.
          npm install -g @github/copilot 2>/dev/null || true
          BODY=$(copilot -p \
            "Write ONLY a git commit body (no subject line) summarising these changes. \
             Output plain text only ‚Äî no markdown fences, no code blocks, no tool \
             calls, no reasoning steps. Be concise. \
             Commits: $LOG --- Diff stat: $STAT" \
            2>/dev/null) || true

          # Clean copilot output: if the response is wrapped in a fenced code
          # block (```...```) with tool-call / reasoning preamble before it,
          # extract only the content between the first pair of ``` markers.
          if [ -n "$BODY" ] && echo "$BODY" | grep -q '^```'; then
            BODY=$(echo "$BODY" | awk '/^```/{if(f){exit}else{f=1;next}} f{print}')
          fi

          # Strip any remaining copilot agent step-output lines
          # (‚óè action headers, $ shell commands, ‚îî result summaries)
          if [ -n "$BODY" ]; then
            BODY=$(echo "$BODY" | grep -vE '^\s*(‚óè|‚îî|\$ )')
          fi

          # Reject output that looks like error messages rather than real content
          if [ -n "$BODY" ] && echo "$BODY" | grep -qiE '(error:|unknown option|--help|installed successfully)'; then
            BODY=""
          fi

          # Fallback: use PR body as description
          if [ -z "$BODY" ]; then
            BODY=$(gh api "repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
              --jq '.body // empty') || true
          fi

          # Build full commit message: subject + optional body
          if [ -n "$BODY" ]; then
            MESSAGE=$(printf '%s\n\n%s' "$TITLE" "$BODY")
          else
            MESSAGE="$TITLE"
          fi

          # Squash
          git reset --soft "$MERGE_BASE"
          git commit -m "$MESSAGE"
          git push --force-with-lease

          {
            echo "### Squashed $COMMIT_COUNT commits"
            echo ""
            echo '```'
            echo "$MESSAGE"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      # ‚îÄ‚îÄ 7. Summary comment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: Post summary comment
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STATUS="${{ job.status }}"
          PR_NUMBER="${{ steps.ctx.outputs.pr_number }}"

          # Add reaction to original comment (only for issue_comment trigger)
          if [ "${{ steps.ctx.outputs.has_comment }}" = "true" ]; then
            REACTION="rocket"
            if [ "$STATUS" != "success" ]; then
              REACTION="confused"
            fi
            gh api "repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions" \
              -f content="$REACTION" --silent || true
          fi

          # Post summary
          if [ "$STATUS" = "success" ]; then
            BODY="‚úÖ **Done!** Rebase/squash completed successfully. See the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details."
          else
            BODY="‚ùå **Failed.** The rebase/squash operation did not complete. See the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details."
          fi

          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body "$BODY"
